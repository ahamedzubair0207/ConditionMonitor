import { InjectionToken, Injectable, NgZone, Inject, PLATFORM_ID, defineInjectable, inject, NgModule, Directive, ChangeDetectorRef, Input, HostListener, TemplateRef, ViewContainerRef } from '@angular/core';
import { isPlatformServer, DOCUMENT, CommonModule } from '@angular/common';
import { BehaviorSubject, merge, fromEvent, throwError, EMPTY, interval, of, Subject, combineLatest } from 'rxjs';
import { debounceTime, map, flatMap, tap, take, takeUntil, distinctUntilChanged, startWith, shareReplay, filter, delay } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const isIphone = (/**
 * @return {?}
 */
() => typeof window === 'undefined' || typeof window.navigator === 'undefined'
    ? false
    : window.navigator.userAgent.match(/iPhone/)
        ? true :
        false);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const FS_FULLSCREEN_REQUEST_EVENTS = new InjectionToken('fs.fullscreen.request');
/** @type {?} */
const FS_FULLSCREEN_EXIT_EVENTS = new InjectionToken('fs.fullscreen.exit');
/** @type {?} */
const FS_FULLSCREEN_CHANGE_EVENTS = new InjectionToken('fs.fullscreen.change');
/** @type {?} */
const FS_FULLSCREEN_ELEMENT_ERROR_EVENTS = new InjectionToken('fs.fullscreen.error');
/** @type {?} */
const FS_FULLSCREEN_ELEMENT = new InjectionToken('fs.fullscreen.element');
/** @type {?} */
const FS_FULLSCREEN_ENABLED = new InjectionToken('fs.fullscreen.enabled');
/** @type {?} */
const FS_FULLSCREEN_ENABLED_FUNC = new InjectionToken('fs.fullscreen.enabled-func');
/** @type {?} */
const FS_FULLSCREEN_IOS_POLL_ENABLED = new InjectionToken('fs.fullscreen.ios.poll.enabled');
/** @type {?} */
const FS_FULLSCREEN_IOS_POLL_MS = new InjectionToken('fs.fullscreen.ios.poll.ms');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const isKeyTrue = (/**
 * @param {?} platformKeys
 * @return {?}
 */
(platformKeys) => (/**
 * @param {?} doc
 * @return {?}
 */
(doc) => platformKeys.reduce((/**
 * @param {?} acc
 * @param {?} curr
 * @return {?}
 */
(acc, curr) => acc || doc[curr] ? true : false), false)));
/** @type {?} */
const fullscreenChangeError = (/**
 * @param {?} platformKeys
 * @return {?}
 */
(platformKeys) => (/**
 * @param {?} doc
 * @return {?}
 */
(doc) => merge(...platformKeys.map((/**
 * @param {?} key
 * @return {?}
 */
key => fromEvent(doc, key)))).pipe(debounceTime(0))));
/** @type {?} */
const filterAndExecute = (/**
 * @param {?} ref
 * @return {?}
 */
(ref) => (/**
 * @param {?} arr
 * @return {?}
 */
(arr) => {
    /** @type {?} */
    const funcStringIdx = arr.findIndex((/**
     * @param {?} a
     * @return {?}
     */
    a => typeof ref[a] === 'function'));
    if (funcStringIdx >= 0) {
        ref[arr[funcStringIdx]]();
    }
}));
class FloFullscreenService {
    // tslint:disable: readonly-array
    /**
     * @param {?} zone
     * @param {?} doc
     * @param {?} platformId
     * @param {?} requestEventKeys
     * @param {?} exitEventKeys
     * @param {?} elementKeys
     * @param {?} changeEventKeys
     * @param {?} elementErrorEventKeys
     * @param {?} enabledKeys
     * @param {?} enabledFunc
     * @param {?} iosPollrate
     * @param {?} iosPollEnabled
     */
    constructor(zone, doc, platformId, requestEventKeys, exitEventKeys, elementKeys, changeEventKeys, elementErrorEventKeys, enabledKeys, enabledFunc, iosPollrate, iosPollEnabled) {
        this.zone = zone;
        this.doc = doc;
        this.platformId = platformId;
        this.requestEventKeys = requestEventKeys;
        this.exitEventKeys = exitEventKeys;
        this.elementKeys = elementKeys;
        this.changeEventKeys = changeEventKeys;
        this.elementErrorEventKeys = elementErrorEventKeys;
        this.enabledKeys = enabledKeys;
        this.enabledFunc = enabledFunc;
        this.iosPollrate = iosPollrate;
        this.iosPollEnabled = iosPollEnabled;
        this.iOSVideoState = new BehaviorSubject(false);
        this.isFullscreen = (/**
         * @param {?=} doc
         * @return {?}
         */
        (doc = this.doc) => isPlatformServer(this.platformId) ? false : isKeyTrue(this.elementKeys)(doc) || this.iOSVideoState.getValue());
        this.fullscreenError$ = fullscreenChangeError(this.elementErrorEventKeys)(this.doc).pipe(map((/**
         * @param {?} e
         * @return {?}
         */
        e => throwError(e))));
        this.iosVideoBypass = (/**
         * @param {?} pasthrough
         * @return {?}
         */
        (pasthrough) => isIphone() ? ['webkitEnterFullscreen'] : pasthrough);
        this.extractVideoForIphoneIfRequired = (/**
         * @param {?} element
         * @return {?}
         */
        (element) => isIphone() && !(element instanceof HTMLVideoElement)
            ? element.querySelector('video') || element
            : element);
        this.iosPoller = (/**
         * @return {?}
         */
        () => !this.iosPollEnabled
            ? EMPTY
            : this.zone.runOutsideAngular((/**
             * @return {?}
             */
            () => interval(this.iosPollrate).pipe(map((/**
             * @return {?}
             */
            () => Array.from(((/** @type {?} */ (this.doc))).querySelectorAll('video')))), flatMap((/**
             * @param {?} videoElements
             * @return {?}
             */
            videoElements => merge(...videoElements.map((/**
             * @param {?} ve
             * @return {?}
             */
            ve => fromEvent(ve, 'webkitbeginfullscreen').pipe(tap((/**
             * @return {?}
             */
            () => this.iOSVideoState.next(true))), take(1)))), ...videoElements.map((/**
             * @param {?} ve
             * @return {?}
             */
            ve => fromEvent(ve, 'webkitendfullscreen').pipe(tap((/**
             * @return {?}
             */
            () => this.iOSVideoState.next(false))), take(1))))))), takeUntil(this.iOSVideoState)))));
        this.fullscreen$ = isPlatformServer(this.platformId)
            ? of(false)
            : merge(...this.changeEventKeys.map((/**
             * @param {?} key
             * @return {?}
             */
            key => fromEvent(this.doc, key))), this.fullscreenError$, this.iosPoller()).pipe(debounceTime(0), map((/**
             * @return {?}
             */
            () => this.isFullscreen())), distinctUntilChanged(), startWith(this.isFullscreen()), shareReplay(1));
        this.fullscreenIsSupported = (/**
         * @param {?=} elm
         * @return {?}
         */
        (elm) => (isPlatformServer(this.platformId)
            ? of(false)
            : isKeyTrue(this.enabledKeys)(this.doc)
                ? of(true)
                : !elm
                    ? of(false)
                    : this.enabledFunc(elm)).pipe(shareReplay(1)));
        this.canGoFullscreen = (/**
         * @param {?=} elm
         * @return {?}
         */
        (elm) => (isPlatformServer(this.platformId)
            ? of(false)
            : this.fullscreenIsSupported(elm)
                .pipe(flatMap((/**
             * @param {?} isSupported
             * @return {?}
             */
            isSupported => !isSupported
                ? of(false)
                : this.fullscreen$.pipe(map((/**
                 * @param {?} isfs
                 * @return {?}
                 */
                isfs => isfs ? false : true))))))).pipe(shareReplay(1)));
        this.isFullscreen$ = this.fullscreen$.pipe(filter((/**
         * @param {?} v
         * @return {?}
         */
        v => v === true)));
        this.isNotFullscreen = this.fullscreen$.pipe(filter((/**
         * @param {?} v
         * @return {?}
         */
        v => v === false)));
        this.exitFullscreen = (/**
         * @return {?}
         */
        () => filterAndExecute(this.doc)(this.exitEventKeys));
        this.goFullscreen = (/**
         * @param {?=} elm
         * @return {?}
         */
        (elm = this.doc.body) => filterAndExecute(elm)(this.iosVideoBypass(this.requestEventKeys)));
    }
}
FloFullscreenService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
FloFullscreenService.ctorParameters = () => [
    { type: NgZone },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: String, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: Array, decorators: [{ type: Inject, args: [FS_FULLSCREEN_REQUEST_EVENTS,] }] },
    { type: Array, decorators: [{ type: Inject, args: [FS_FULLSCREEN_EXIT_EVENTS,] }] },
    { type: Array, decorators: [{ type: Inject, args: [FS_FULLSCREEN_ELEMENT,] }] },
    { type: Array, decorators: [{ type: Inject, args: [FS_FULLSCREEN_CHANGE_EVENTS,] }] },
    { type: Array, decorators: [{ type: Inject, args: [FS_FULLSCREEN_ELEMENT_ERROR_EVENTS,] }] },
    { type: Array, decorators: [{ type: Inject, args: [FS_FULLSCREEN_ENABLED,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [FS_FULLSCREEN_ENABLED_FUNC,] }] },
    { type: Number, decorators: [{ type: Inject, args: [FS_FULLSCREEN_IOS_POLL_MS,] }] },
    { type: Boolean, decorators: [{ type: Inject, args: [FS_FULLSCREEN_IOS_POLL_ENABLED,] }] }
];
/** @nocollapse */ FloFullscreenService.ngInjectableDef = defineInjectable({ factory: function FloFullscreenService_Factory() { return new FloFullscreenService(inject(NgZone), inject(DOCUMENT), inject(PLATFORM_ID), inject(FS_FULLSCREEN_REQUEST_EVENTS), inject(FS_FULLSCREEN_EXIT_EVENTS), inject(FS_FULLSCREEN_ELEMENT), inject(FS_FULLSCREEN_CHANGE_EVENTS), inject(FS_FULLSCREEN_ELEMENT_ERROR_EVENTS), inject(FS_FULLSCREEN_ENABLED), inject(FS_FULLSCREEN_ENABLED_FUNC), inject(FS_FULLSCREEN_IOS_POLL_MS), inject(FS_FULLSCREEN_IOS_POLL_ENABLED)); }, token: FloFullscreenService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_FS_FULLSCREEN_REQUEST_EVENTS = [
    'requestFullscreen',
    'webkitRequestFullscreen',
    'webkitRequestFullScreen',
    'mozRequestFullScreen',
    'msRequestFullscreen'
];
/** @type {?} */
const DEFAULT_FS_FULLSCREEN_EXIT_EVENTS = [
    'exitFullscreen',
    'webkitExitFullscreen',
    'webkitCancelFullScreen',
    'mozCancelFullScreen',
    'msExitFullscreen'
];
/** @type {?} */
const DEFAULT_FS_FULLSCREEN_ELEMENT_ERROR_EVENTS = [
    'fullscreenerror',
    'webkitfullscreenerror',
    'webkitfullscreenerror',
    'mozfullscreenerror',
    'MSFullscreenError'
];
/** @type {?} */
const DEFAULT_FS_FULLSCREEN_ELEMENT = [
    'fullscreenElement',
    'webkitFullscreenElement',
    'webkitCurrentFullScreenElement',
    'mozFullScreenElement',
    'msFullscreenElement'
];
/** @type {?} */
const DEFAULT_FS_FULLSCREEN_ENABLED = [
    'fullscreenEnabled',
    'mozFullscreenEnabled',
    'webkitFullscreenEnabled',
    'msFullscreenEnabled'
];
/** @type {?} */
const DEFAULT_FS_FULLSCREEN_CHANGE_EVENTS = [
    'fullscreenchange',
    'webkitfullscreenchange',
    'mozfullscreenchange',
    'MSFullscreenChange'
];
/**
 * @return {?}
 */
function DEFAULT_FS_FULLSCREEN_ENABLED_FUNC() {
    /** @type {?} */
    const lambda = (/**
     * @param {?} elm
     * @return {?}
     */
    (elm) => {
        /** @type {?} */
        const _elm = elm instanceof HTMLVideoElement ? elm : elm.querySelector('video');
        return !_elm ? of(false) : ((/** @type {?} */ (_elm))).readyState >= 2
            ? of(true)
            : fromEvent(_elm, 'loadedmetadata').pipe(map((/**
             * @param {?} evt
             * @return {?}
             */
            evt => !evt.target ? false : ((/** @type {?} */ (evt.target))).webkitSupportsFullscreen)), take(1));
    });
    return lambda;
}
/** @type {?} */
const DEFAULT_FS_FULLSCREEN_IOS_POLL_ENABLED = true;
/** @type {?} */
const DEFAULT_FS_FULLSCREEN_IOS_POLL_MS = 60;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0 = DEFAULT_FS_FULLSCREEN_REQUEST_EVENTS, ɵ1 = DEFAULT_FS_FULLSCREEN_EXIT_EVENTS, ɵ2 = DEFAULT_FS_FULLSCREEN_CHANGE_EVENTS, ɵ3 = DEFAULT_FS_FULLSCREEN_ELEMENT_ERROR_EVENTS, ɵ4 = DEFAULT_FS_FULLSCREEN_ELEMENT, ɵ5 = DEFAULT_FS_FULLSCREEN_ENABLED, ɵ6 = DEFAULT_FS_FULLSCREEN_ENABLED_FUNC, ɵ7 = DEFAULT_FS_FULLSCREEN_IOS_POLL_MS, ɵ8 = DEFAULT_FS_FULLSCREEN_IOS_POLL_ENABLED;
class FloFullscreenCommonModule {
    /**
     * @param {?} config
     * @return {?}
     */
    static config(config) {
        return {
            ngModule: FloFullscreenCommonModule,
            providers: [
                {
                    provide: FS_FULLSCREEN_IOS_POLL_ENABLED,
                    useValue: config.ios && typeof config.ios.enabled === 'boolean' ? config.ios.enabled : DEFAULT_FS_FULLSCREEN_IOS_POLL_ENABLED
                },
                {
                    provide: FS_FULLSCREEN_IOS_POLL_MS,
                    useValue: config.ios && typeof config.ios.pollDurationMs === 'number'
                        ? config.ios.pollDurationMs
                        : DEFAULT_FS_FULLSCREEN_IOS_POLL_MS
                }
            ]
        };
    }
}
FloFullscreenCommonModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [CommonModule],
                providers: [
                    FloFullscreenService,
                    { provide: FS_FULLSCREEN_REQUEST_EVENTS, useValue: ɵ0 },
                    { provide: FS_FULLSCREEN_EXIT_EVENTS, useValue: ɵ1 },
                    { provide: FS_FULLSCREEN_CHANGE_EVENTS, useValue: ɵ2 },
                    { provide: FS_FULLSCREEN_ELEMENT_ERROR_EVENTS, useValue: ɵ3 },
                    { provide: FS_FULLSCREEN_ELEMENT, useValue: ɵ4 },
                    { provide: FS_FULLSCREEN_ENABLED, useValue: ɵ5 },
                    { provide: FS_FULLSCREEN_ENABLED_FUNC, useFactory: ɵ6 },
                    { provide: FS_FULLSCREEN_IOS_POLL_MS, useValue: ɵ7 },
                    { provide: FS_FULLSCREEN_IOS_POLL_ENABLED, useValue: ɵ8 }
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// tslint:disable: readonly-keyword
// tslint:disable: no-object-mutation
class FloClickToEnterFullscreenDirective {
    /**
     * @param {?} fs
     * @param {?} doc
     * @param {?} cd
     */
    constructor(fs, doc, cd) {
        this.fs = fs;
        this.doc = doc;
        this.cd = cd;
    }
    /**
     * @return {?}
     */
    get floClickToEnterFullscreen() {
        return this._element;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set floClickToEnterFullscreen(val) {
        if (val instanceof HTMLElement) {
            this._element = val;
        }
        else {
            this._element = this.doc.body;
        }
    }
    /**
     * @return {?}
     */
    click() {
        this.cd.detectChanges();
        this.fs.isNotFullscreen.pipe(take(1)).subscribe((/**
         * @param {?} _
         * @return {?}
         */
        _ => {
            // should check for nested video elements to make iOS dev easier
            this.fs.goFullscreen(this.fs.extractVideoForIphoneIfRequired(this.floClickToEnterFullscreen));
        }));
    }
}
FloClickToEnterFullscreenDirective.decorators = [
    { type: Directive, args: [{
                selector: '[floClickToEnterFullscreen]',
            },] }
];
/** @nocollapse */
FloClickToEnterFullscreenDirective.ctorParameters = () => [
    { type: FloFullscreenService },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: ChangeDetectorRef }
];
FloClickToEnterFullscreenDirective.propDecorators = {
    floClickToEnterFullscreen: [{ type: Input }],
    click: [{ type: HostListener, args: ['click', [],] }]
};
class FloClickToExitFullscreenDirective {
    /**
     * @param {?} fs
     */
    constructor(fs) {
        this.fs = fs;
    }
    /**
     * @return {?}
     */
    click() {
        this.fs.exitFullscreen();
    }
}
FloClickToExitFullscreenDirective.decorators = [
    { type: Directive, args: [{
                selector: '[floClickToExitFullscreen]',
            },] }
];
/** @nocollapse */
FloClickToExitFullscreenDirective.ctorParameters = () => [
    { type: FloFullscreenService }
];
FloClickToExitFullscreenDirective.propDecorators = {
    click: [{ type: HostListener, args: ['click', [],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FloFullscreenToggleModule {
}
FloFullscreenToggleModule.decorators = [
    { type: NgModule, args: [{
                imports: [FloFullscreenCommonModule],
                declarations: [
                    FloClickToEnterFullscreenDirective,
                    FloClickToExitFullscreenDirective
                ],
                exports: [
                    FloClickToEnterFullscreenDirective,
                    FloClickToExitFullscreenDirective
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// tslint:disable: readonly-keyword
/**
 * @abstract
 */
class FloFullscreenDirective {
    /**
     * @param {?} tr
     * @param {?} vc
     * @param {?} fs
     * @param {?} cd
     * @param {?} iosPollEnabled
     * @param {?} iosPollrate
     * @param {?} zone
     */
    constructor(tr, vc, fs, cd, iosPollEnabled, iosPollrate, zone) {
        this.tr = tr;
        this.vc = vc;
        this.fs = fs;
        this.cd = cd;
        this.iosPollEnabled = iosPollEnabled;
        this.iosPollrate = iosPollrate;
        this.zone = zone;
        this.elmSource = new Subject();
        this.showWhenFullscreen = false;
        this.ngOnDestroy$ = new Subject();
        this.elm = (/**
         * @return {?}
         */
        () => this.elmInputKey ? (/** @type {?} */ (this[this.elmInputKey])) : undefined);
        this.elm$ = this.elmSource.asObservable();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        combineLatest(this.fs.fullscreen$, this.elm$.pipe(tap((/**
         * @return {?}
         */
        () => this.cd.detectChanges())), startWith(this.elm()), delay(0), flatMap((/**
         * @param {?} elm
         * @return {?}
         */
        elm => this.iosPollEnabled && isIphone()
            ? this.zone.runOutsideAngular((/**
             * @return {?}
             */
            () => interval(this.iosPollrate).pipe(flatMap((/**
             * @return {?}
             */
            () => this.fs.fullscreenIsSupported(elm))), distinctUntilChanged(), takeUntil(this.ngOnDestroy$))))
            : this.fs.fullscreenIsSupported(elm))), takeUntil(this.ngOnDestroy$))).pipe(takeUntil(this.ngOnDestroy$)).subscribe((/**
         * @param {?} res
         * @return {?}
         */
        res => {
            /** @type {?} */
            const isFullscreen = res[0];
            /** @type {?} */
            const isSupported = res[1];
            this.vc.clear();
            if (this.showWhenFullscreen) { // exit
                if (isFullscreen) {
                    this.vc.createEmbeddedView(this.tr);
                }
            }
            else if (!isFullscreen) { // enter
                if (isSupported) {
                    this.vc.createEmbeddedView(this.tr);
                }
            }
            this.cd.detectChanges();
        }));
    }
    /**
     * @param {?} sc
     * @return {?}
     */
    ngOnChanges(sc) {
        if (this.elmInputKey && sc[this.elmInputKey]) {
            this.elmSource.next(sc[this.elmInputKey].currentValue);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.ngOnDestroy$.next();
        this.ngOnDestroy$.complete();
    }
}
/** @nocollapse */
FloFullscreenDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef },
    { type: FloFullscreenService },
    { type: ChangeDetectorRef },
    { type: Boolean, decorators: [{ type: Inject, args: [FS_FULLSCREEN_IOS_POLL_ENABLED,] }] },
    { type: Number, decorators: [{ type: Inject, args: [FS_FULLSCREEN_IOS_POLL_MS,] }] },
    { type: NgZone }
];
/** @type {?} */
const IF_FS_SELECTOR = 'floIfFullscreen';
class FloFullscreenOnDirective extends FloFullscreenDirective {
    /**
     * @param {?} tr
     * @param {?} vc
     * @param {?} fs
     * @param {?} cd
     * @param {?} iosPollEnabled
     * @param {?} iosPollrate
     * @param {?} zone
     */
    constructor(tr, vc, fs, cd, iosPollEnabled, iosPollrate, zone) {
        super(tr, vc, fs, cd, iosPollEnabled, iosPollrate, zone);
        this.tr = tr;
        this.vc = vc;
        this.fs = fs;
        this.cd = cd;
        this.iosPollEnabled = iosPollEnabled;
        this.iosPollrate = iosPollrate;
        this.zone = zone;
        this.elmInputKey = IF_FS_SELECTOR;
        this.showWhenFullscreen = true;
    }
}
FloFullscreenOnDirective.decorators = [
    { type: Directive, args: [{
                selector: `[${IF_FS_SELECTOR}]`,
                inputs: [IF_FS_SELECTOR]
            },] }
];
/** @nocollapse */
FloFullscreenOnDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef },
    { type: FloFullscreenService },
    { type: ChangeDetectorRef },
    { type: Boolean, decorators: [{ type: Inject, args: [FS_FULLSCREEN_IOS_POLL_ENABLED,] }] },
    { type: Number, decorators: [{ type: Inject, args: [FS_FULLSCREEN_IOS_POLL_MS,] }] },
    { type: NgZone }
];
/** @type {?} */
const IF_NOT_FS_SELECTOR = 'floIfNotFullscreen';
class FloFullscreenOffDirective extends FloFullscreenDirective {
    /**
     * @param {?} tr
     * @param {?} vc
     * @param {?} fs
     * @param {?} cd
     * @param {?} iosPollEnabled
     * @param {?} iosPollrate
     * @param {?} zone
     */
    constructor(tr, vc, fs, cd, iosPollEnabled, iosPollrate, zone) {
        super(tr, vc, fs, cd, iosPollEnabled, iosPollrate, zone);
        this.tr = tr;
        this.vc = vc;
        this.fs = fs;
        this.cd = cd;
        this.iosPollEnabled = iosPollEnabled;
        this.iosPollrate = iosPollrate;
        this.zone = zone;
        this.elmInputKey = IF_NOT_FS_SELECTOR;
        this.showWhenFullscreen = false;
    }
}
FloFullscreenOffDirective.decorators = [
    { type: Directive, args: [{
                selector: `[${IF_NOT_FS_SELECTOR}]`,
                inputs: [IF_NOT_FS_SELECTOR]
            },] }
];
/** @nocollapse */
FloFullscreenOffDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef },
    { type: FloFullscreenService },
    { type: ChangeDetectorRef },
    { type: Boolean, decorators: [{ type: Inject, args: [FS_FULLSCREEN_IOS_POLL_ENABLED,] }] },
    { type: Number, decorators: [{ type: Inject, args: [FS_FULLSCREEN_IOS_POLL_MS,] }] },
    { type: NgZone }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FloFullscreenSwitchModule {
}
FloFullscreenSwitchModule.decorators = [
    { type: NgModule, args: [{
                imports: [FloFullscreenCommonModule],
                declarations: [
                    FloFullscreenOnDirective,
                    FloFullscreenOffDirective
                ],
                exports: [
                    FloFullscreenOnDirective,
                    FloFullscreenOffDirective
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FloFullscreenModule {
}
FloFullscreenModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    FloFullscreenCommonModule,
                    FloFullscreenSwitchModule,
                    FloFullscreenToggleModule
                ],
                exports: [
                    FloFullscreenCommonModule,
                    FloFullscreenSwitchModule,
                    FloFullscreenToggleModule
                ]
            },] }
];

export { DEFAULT_FS_FULLSCREEN_CHANGE_EVENTS, DEFAULT_FS_FULLSCREEN_ELEMENT, DEFAULT_FS_FULLSCREEN_ELEMENT_ERROR_EVENTS, DEFAULT_FS_FULLSCREEN_ENABLED, DEFAULT_FS_FULLSCREEN_ENABLED_FUNC, DEFAULT_FS_FULLSCREEN_EXIT_EVENTS, DEFAULT_FS_FULLSCREEN_IOS_POLL_ENABLED, DEFAULT_FS_FULLSCREEN_IOS_POLL_MS, DEFAULT_FS_FULLSCREEN_REQUEST_EVENTS, FS_FULLSCREEN_CHANGE_EVENTS, FS_FULLSCREEN_ELEMENT, FS_FULLSCREEN_ELEMENT_ERROR_EVENTS, FS_FULLSCREEN_ENABLED, FS_FULLSCREEN_ENABLED_FUNC, FS_FULLSCREEN_EXIT_EVENTS, FS_FULLSCREEN_IOS_POLL_ENABLED, FS_FULLSCREEN_IOS_POLL_MS, FS_FULLSCREEN_REQUEST_EVENTS, FloClickToEnterFullscreenDirective, FloClickToExitFullscreenDirective, FloFullscreenCommonModule, FloFullscreenDirective, FloFullscreenModule, FloFullscreenOffDirective, FloFullscreenOnDirective, FloFullscreenService, FloFullscreenSwitchModule, FloFullscreenToggleModule, isIphone };
//# sourceMappingURL=flosportsinc-ng-fullscreen.js.map
