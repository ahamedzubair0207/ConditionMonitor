import { InjectionToken, defineInjectable, inject, NgZone, PLATFORM_ID, Injectable, Inject, NgModule, Directive, ChangeDetectorRef, Input, HostListener, TemplateRef, ViewContainerRef } from '@angular/core';
import { __spread, __extends } from 'tslib';
import { DOCUMENT, isPlatformServer, CommonModule } from '@angular/common';
import { BehaviorSubject, merge, fromEvent, throwError, EMPTY, interval, of, combineLatest, Subject } from 'rxjs';
import { debounceTime, map, flatMap, tap, take, takeUntil, distinctUntilChanged, startWith, shareReplay, filter, delay } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var isIphone = (/**
 * @return {?}
 */
function () { return typeof window === 'undefined' || typeof window.navigator === 'undefined'
    ? false
    : window.navigator.userAgent.match(/iPhone/)
        ? true :
        false; });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var FS_FULLSCREEN_REQUEST_EVENTS = new InjectionToken('fs.fullscreen.request');
/** @type {?} */
var FS_FULLSCREEN_EXIT_EVENTS = new InjectionToken('fs.fullscreen.exit');
/** @type {?} */
var FS_FULLSCREEN_CHANGE_EVENTS = new InjectionToken('fs.fullscreen.change');
/** @type {?} */
var FS_FULLSCREEN_ELEMENT_ERROR_EVENTS = new InjectionToken('fs.fullscreen.error');
/** @type {?} */
var FS_FULLSCREEN_ELEMENT = new InjectionToken('fs.fullscreen.element');
/** @type {?} */
var FS_FULLSCREEN_ENABLED = new InjectionToken('fs.fullscreen.enabled');
/** @type {?} */
var FS_FULLSCREEN_ENABLED_FUNC = new InjectionToken('fs.fullscreen.enabled-func');
/** @type {?} */
var FS_FULLSCREEN_IOS_POLL_ENABLED = new InjectionToken('fs.fullscreen.ios.poll.enabled');
/** @type {?} */
var FS_FULLSCREEN_IOS_POLL_MS = new InjectionToken('fs.fullscreen.ios.poll.ms');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var isKeyTrue = (/**
 * @param {?} platformKeys
 * @return {?}
 */
function (platformKeys) { return (/**
 * @param {?} doc
 * @return {?}
 */
function (doc) {
    return platformKeys.reduce((/**
     * @param {?} acc
     * @param {?} curr
     * @return {?}
     */
    function (acc, curr) { return acc || doc[curr] ? true : false; }), false);
}); });
/** @type {?} */
var fullscreenChangeError = (/**
 * @param {?} platformKeys
 * @return {?}
 */
function (platformKeys) { return (/**
 * @param {?} doc
 * @return {?}
 */
function (doc) {
    return merge.apply(void 0, __spread(platformKeys.map((/**
     * @param {?} key
     * @return {?}
     */
    function (key) { return fromEvent(doc, key); })))).pipe(debounceTime(0));
}); });
/** @type {?} */
var filterAndExecute = (/**
 * @param {?} ref
 * @return {?}
 */
function (ref) { return (/**
 * @param {?} arr
 * @return {?}
 */
function (arr) {
    /** @type {?} */
    var funcStringIdx = arr.findIndex((/**
     * @param {?} a
     * @return {?}
     */
    function (a) { return typeof ref[a] === 'function'; }));
    if (funcStringIdx >= 0) {
        ref[arr[funcStringIdx]]();
    }
}); });
var FloFullscreenService = /** @class */ (function () {
    // tslint:disable: readonly-array
    function FloFullscreenService(zone, doc, platformId, requestEventKeys, exitEventKeys, elementKeys, changeEventKeys, elementErrorEventKeys, enabledKeys, enabledFunc, iosPollrate, iosPollEnabled) {
        var _this = this;
        this.zone = zone;
        this.doc = doc;
        this.platformId = platformId;
        this.requestEventKeys = requestEventKeys;
        this.exitEventKeys = exitEventKeys;
        this.elementKeys = elementKeys;
        this.changeEventKeys = changeEventKeys;
        this.elementErrorEventKeys = elementErrorEventKeys;
        this.enabledKeys = enabledKeys;
        this.enabledFunc = enabledFunc;
        this.iosPollrate = iosPollrate;
        this.iosPollEnabled = iosPollEnabled;
        this.iOSVideoState = new BehaviorSubject(false);
        this.isFullscreen = (/**
         * @param {?=} doc
         * @return {?}
         */
        function (doc) {
            if (doc === void 0) { doc = _this.doc; }
            return isPlatformServer(_this.platformId) ? false : isKeyTrue(_this.elementKeys)(doc) || _this.iOSVideoState.getValue();
        });
        this.fullscreenError$ = fullscreenChangeError(this.elementErrorEventKeys)(this.doc).pipe(map((/**
         * @param {?} e
         * @return {?}
         */
        function (e) { return throwError(e); })));
        this.iosVideoBypass = (/**
         * @param {?} pasthrough
         * @return {?}
         */
        function (pasthrough) { return isIphone() ? ['webkitEnterFullscreen'] : pasthrough; });
        this.extractVideoForIphoneIfRequired = (/**
         * @param {?} element
         * @return {?}
         */
        function (element) { return isIphone() && !(element instanceof HTMLVideoElement)
            ? element.querySelector('video') || element
            : element; });
        this.iosPoller = (/**
         * @return {?}
         */
        function () { return !_this.iosPollEnabled
            ? EMPTY
            : _this.zone.runOutsideAngular((/**
             * @return {?}
             */
            function () {
                return interval(_this.iosPollrate).pipe(map((/**
                 * @return {?}
                 */
                function () { return Array.from(((/** @type {?} */ (_this.doc))).querySelectorAll('video')); })), flatMap((/**
                 * @param {?} videoElements
                 * @return {?}
                 */
                function (videoElements) { return merge.apply(void 0, __spread(videoElements.map((/**
                 * @param {?} ve
                 * @return {?}
                 */
                function (ve) { return fromEvent(ve, 'webkitbeginfullscreen').pipe(tap((/**
                 * @return {?}
                 */
                function () { return _this.iOSVideoState.next(true); })), take(1)); })), videoElements.map((/**
                 * @param {?} ve
                 * @return {?}
                 */
                function (ve) { return fromEvent(ve, 'webkitendfullscreen').pipe(tap((/**
                 * @return {?}
                 */
                function () { return _this.iOSVideoState.next(false); })), take(1)); })))); })), takeUntil(_this.iOSVideoState));
            })); });
        this.fullscreen$ = isPlatformServer(this.platformId)
            ? of(false)
            : merge.apply(void 0, __spread(this.changeEventKeys.map((/**
             * @param {?} key
             * @return {?}
             */
            function (key) { return fromEvent(_this.doc, key); })), [this.fullscreenError$,
                this.iosPoller()])).pipe(debounceTime(0), map((/**
             * @return {?}
             */
            function () { return _this.isFullscreen(); })), distinctUntilChanged(), startWith(this.isFullscreen()), shareReplay(1));
        this.fullscreenIsSupported = (/**
         * @param {?=} elm
         * @return {?}
         */
        function (elm) {
            return (isPlatformServer(_this.platformId)
                ? of(false)
                : isKeyTrue(_this.enabledKeys)(_this.doc)
                    ? of(true)
                    : !elm
                        ? of(false)
                        : _this.enabledFunc(elm)).pipe(shareReplay(1));
        });
        this.canGoFullscreen = (/**
         * @param {?=} elm
         * @return {?}
         */
        function (elm) {
            return (isPlatformServer(_this.platformId)
                ? of(false)
                : _this.fullscreenIsSupported(elm)
                    .pipe(flatMap((/**
                 * @param {?} isSupported
                 * @return {?}
                 */
                function (isSupported) { return !isSupported
                    ? of(false)
                    : _this.fullscreen$.pipe(map((/**
                     * @param {?} isfs
                     * @return {?}
                     */
                    function (isfs) { return isfs ? false : true; }))); })))).pipe(shareReplay(1));
        });
        this.isFullscreen$ = this.fullscreen$.pipe(filter((/**
         * @param {?} v
         * @return {?}
         */
        function (v) { return v === true; })));
        this.isNotFullscreen = this.fullscreen$.pipe(filter((/**
         * @param {?} v
         * @return {?}
         */
        function (v) { return v === false; })));
        this.exitFullscreen = (/**
         * @return {?}
         */
        function () { return filterAndExecute(_this.doc)(_this.exitEventKeys); });
        this.goFullscreen = (/**
         * @param {?=} elm
         * @return {?}
         */
        function (elm) {
            if (elm === void 0) { elm = _this.doc.body; }
            return filterAndExecute(elm)(_this.iosVideoBypass(_this.requestEventKeys));
        });
    }
    FloFullscreenService.decorators = [
        { type: Injectable, args: [{ providedIn: 'root' },] }
    ];
    /** @nocollapse */
    FloFullscreenService.ctorParameters = function () { return [
        { type: NgZone },
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
        { type: String, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
        { type: Array, decorators: [{ type: Inject, args: [FS_FULLSCREEN_REQUEST_EVENTS,] }] },
        { type: Array, decorators: [{ type: Inject, args: [FS_FULLSCREEN_EXIT_EVENTS,] }] },
        { type: Array, decorators: [{ type: Inject, args: [FS_FULLSCREEN_ELEMENT,] }] },
        { type: Array, decorators: [{ type: Inject, args: [FS_FULLSCREEN_CHANGE_EVENTS,] }] },
        { type: Array, decorators: [{ type: Inject, args: [FS_FULLSCREEN_ELEMENT_ERROR_EVENTS,] }] },
        { type: Array, decorators: [{ type: Inject, args: [FS_FULLSCREEN_ENABLED,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [FS_FULLSCREEN_ENABLED_FUNC,] }] },
        { type: Number, decorators: [{ type: Inject, args: [FS_FULLSCREEN_IOS_POLL_MS,] }] },
        { type: Boolean, decorators: [{ type: Inject, args: [FS_FULLSCREEN_IOS_POLL_ENABLED,] }] }
    ]; };
    /** @nocollapse */ FloFullscreenService.ngInjectableDef = defineInjectable({ factory: function FloFullscreenService_Factory() { return new FloFullscreenService(inject(NgZone), inject(DOCUMENT), inject(PLATFORM_ID), inject(FS_FULLSCREEN_REQUEST_EVENTS), inject(FS_FULLSCREEN_EXIT_EVENTS), inject(FS_FULLSCREEN_ELEMENT), inject(FS_FULLSCREEN_CHANGE_EVENTS), inject(FS_FULLSCREEN_ELEMENT_ERROR_EVENTS), inject(FS_FULLSCREEN_ENABLED), inject(FS_FULLSCREEN_ENABLED_FUNC), inject(FS_FULLSCREEN_IOS_POLL_MS), inject(FS_FULLSCREEN_IOS_POLL_ENABLED)); }, token: FloFullscreenService, providedIn: "root" });
    return FloFullscreenService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_FS_FULLSCREEN_REQUEST_EVENTS = [
    'requestFullscreen',
    'webkitRequestFullscreen',
    'webkitRequestFullScreen',
    'mozRequestFullScreen',
    'msRequestFullscreen'
];
/** @type {?} */
var DEFAULT_FS_FULLSCREEN_EXIT_EVENTS = [
    'exitFullscreen',
    'webkitExitFullscreen',
    'webkitCancelFullScreen',
    'mozCancelFullScreen',
    'msExitFullscreen'
];
/** @type {?} */
var DEFAULT_FS_FULLSCREEN_ELEMENT_ERROR_EVENTS = [
    'fullscreenerror',
    'webkitfullscreenerror',
    'webkitfullscreenerror',
    'mozfullscreenerror',
    'MSFullscreenError'
];
/** @type {?} */
var DEFAULT_FS_FULLSCREEN_ELEMENT = [
    'fullscreenElement',
    'webkitFullscreenElement',
    'webkitCurrentFullScreenElement',
    'mozFullScreenElement',
    'msFullscreenElement'
];
/** @type {?} */
var DEFAULT_FS_FULLSCREEN_ENABLED = [
    'fullscreenEnabled',
    'mozFullscreenEnabled',
    'webkitFullscreenEnabled',
    'msFullscreenEnabled'
];
/** @type {?} */
var DEFAULT_FS_FULLSCREEN_CHANGE_EVENTS = [
    'fullscreenchange',
    'webkitfullscreenchange',
    'mozfullscreenchange',
    'MSFullscreenChange'
];
/**
 * @return {?}
 */
function DEFAULT_FS_FULLSCREEN_ENABLED_FUNC() {
    /** @type {?} */
    var lambda = (/**
     * @param {?} elm
     * @return {?}
     */
    function (elm) {
        /** @type {?} */
        var _elm = elm instanceof HTMLVideoElement ? elm : elm.querySelector('video');
        return !_elm ? of(false) : ((/** @type {?} */ (_elm))).readyState >= 2
            ? of(true)
            : fromEvent(_elm, 'loadedmetadata').pipe(map((/**
             * @param {?} evt
             * @return {?}
             */
            function (evt) { return !evt.target ? false : ((/** @type {?} */ (evt.target))).webkitSupportsFullscreen; })), take(1));
    });
    return lambda;
}
/** @type {?} */
var DEFAULT_FS_FULLSCREEN_IOS_POLL_ENABLED = true;
/** @type {?} */
var DEFAULT_FS_FULLSCREEN_IOS_POLL_MS = 60;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ɵ0 = DEFAULT_FS_FULLSCREEN_REQUEST_EVENTS, ɵ1 = DEFAULT_FS_FULLSCREEN_EXIT_EVENTS, ɵ2 = DEFAULT_FS_FULLSCREEN_CHANGE_EVENTS, ɵ3 = DEFAULT_FS_FULLSCREEN_ELEMENT_ERROR_EVENTS, ɵ4 = DEFAULT_FS_FULLSCREEN_ELEMENT, ɵ5 = DEFAULT_FS_FULLSCREEN_ENABLED, ɵ6 = DEFAULT_FS_FULLSCREEN_ENABLED_FUNC, ɵ7 = DEFAULT_FS_FULLSCREEN_IOS_POLL_MS, ɵ8 = DEFAULT_FS_FULLSCREEN_IOS_POLL_ENABLED;
var FloFullscreenCommonModule = /** @class */ (function () {
    function FloFullscreenCommonModule() {
    }
    /**
     * @param {?} config
     * @return {?}
     */
    FloFullscreenCommonModule.config = /**
     * @param {?} config
     * @return {?}
     */
    function (config) {
        return {
            ngModule: FloFullscreenCommonModule,
            providers: [
                {
                    provide: FS_FULLSCREEN_IOS_POLL_ENABLED,
                    useValue: config.ios && typeof config.ios.enabled === 'boolean' ? config.ios.enabled : DEFAULT_FS_FULLSCREEN_IOS_POLL_ENABLED
                },
                {
                    provide: FS_FULLSCREEN_IOS_POLL_MS,
                    useValue: config.ios && typeof config.ios.pollDurationMs === 'number'
                        ? config.ios.pollDurationMs
                        : DEFAULT_FS_FULLSCREEN_IOS_POLL_MS
                }
            ]
        };
    };
    FloFullscreenCommonModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule],
                    exports: [CommonModule],
                    providers: [
                        FloFullscreenService,
                        { provide: FS_FULLSCREEN_REQUEST_EVENTS, useValue: ɵ0 },
                        { provide: FS_FULLSCREEN_EXIT_EVENTS, useValue: ɵ1 },
                        { provide: FS_FULLSCREEN_CHANGE_EVENTS, useValue: ɵ2 },
                        { provide: FS_FULLSCREEN_ELEMENT_ERROR_EVENTS, useValue: ɵ3 },
                        { provide: FS_FULLSCREEN_ELEMENT, useValue: ɵ4 },
                        { provide: FS_FULLSCREEN_ENABLED, useValue: ɵ5 },
                        { provide: FS_FULLSCREEN_ENABLED_FUNC, useFactory: ɵ6 },
                        { provide: FS_FULLSCREEN_IOS_POLL_MS, useValue: ɵ7 },
                        { provide: FS_FULLSCREEN_IOS_POLL_ENABLED, useValue: ɵ8 }
                    ]
                },] }
    ];
    return FloFullscreenCommonModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// tslint:disable: readonly-keyword
// tslint:disable: no-object-mutation
var FloClickToEnterFullscreenDirective = /** @class */ (function () {
    function FloClickToEnterFullscreenDirective(fs, doc, cd) {
        this.fs = fs;
        this.doc = doc;
        this.cd = cd;
    }
    Object.defineProperty(FloClickToEnterFullscreenDirective.prototype, "floClickToEnterFullscreen", {
        get: /**
         * @return {?}
         */
        function () {
            return this._element;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            if (val instanceof HTMLElement) {
                this._element = val;
            }
            else {
                this._element = this.doc.body;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    FloClickToEnterFullscreenDirective.prototype.click = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.cd.detectChanges();
        this.fs.isNotFullscreen.pipe(take(1)).subscribe((/**
         * @param {?} _
         * @return {?}
         */
        function (_) {
            // should check for nested video elements to make iOS dev easier
            _this.fs.goFullscreen(_this.fs.extractVideoForIphoneIfRequired(_this.floClickToEnterFullscreen));
        }));
    };
    FloClickToEnterFullscreenDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[floClickToEnterFullscreen]',
                },] }
    ];
    /** @nocollapse */
    FloClickToEnterFullscreenDirective.ctorParameters = function () { return [
        { type: FloFullscreenService },
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
        { type: ChangeDetectorRef }
    ]; };
    FloClickToEnterFullscreenDirective.propDecorators = {
        floClickToEnterFullscreen: [{ type: Input }],
        click: [{ type: HostListener, args: ['click', [],] }]
    };
    return FloClickToEnterFullscreenDirective;
}());
var FloClickToExitFullscreenDirective = /** @class */ (function () {
    function FloClickToExitFullscreenDirective(fs) {
        this.fs = fs;
    }
    /**
     * @return {?}
     */
    FloClickToExitFullscreenDirective.prototype.click = /**
     * @return {?}
     */
    function () {
        this.fs.exitFullscreen();
    };
    FloClickToExitFullscreenDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[floClickToExitFullscreen]',
                },] }
    ];
    /** @nocollapse */
    FloClickToExitFullscreenDirective.ctorParameters = function () { return [
        { type: FloFullscreenService }
    ]; };
    FloClickToExitFullscreenDirective.propDecorators = {
        click: [{ type: HostListener, args: ['click', [],] }]
    };
    return FloClickToExitFullscreenDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FloFullscreenToggleModule = /** @class */ (function () {
    function FloFullscreenToggleModule() {
    }
    FloFullscreenToggleModule.decorators = [
        { type: NgModule, args: [{
                    imports: [FloFullscreenCommonModule],
                    declarations: [
                        FloClickToEnterFullscreenDirective,
                        FloClickToExitFullscreenDirective
                    ],
                    exports: [
                        FloClickToEnterFullscreenDirective,
                        FloClickToExitFullscreenDirective
                    ]
                },] }
    ];
    return FloFullscreenToggleModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// tslint:disable: readonly-keyword
/**
 * @abstract
 */
var FloFullscreenDirective = /** @class */ (function () {
    function FloFullscreenDirective(tr, vc, fs, cd, iosPollEnabled, iosPollrate, zone) {
        var _this = this;
        this.tr = tr;
        this.vc = vc;
        this.fs = fs;
        this.cd = cd;
        this.iosPollEnabled = iosPollEnabled;
        this.iosPollrate = iosPollrate;
        this.zone = zone;
        this.elmSource = new Subject();
        this.showWhenFullscreen = false;
        this.ngOnDestroy$ = new Subject();
        this.elm = (/**
         * @return {?}
         */
        function () { return _this.elmInputKey ? (/** @type {?} */ (_this[_this.elmInputKey])) : undefined; });
        this.elm$ = this.elmSource.asObservable();
    }
    /**
     * @return {?}
     */
    FloFullscreenDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        combineLatest(this.fs.fullscreen$, this.elm$.pipe(tap((/**
         * @return {?}
         */
        function () { return _this.cd.detectChanges(); })), startWith(this.elm()), delay(0), flatMap((/**
         * @param {?} elm
         * @return {?}
         */
        function (elm) { return _this.iosPollEnabled && isIphone()
            ? _this.zone.runOutsideAngular((/**
             * @return {?}
             */
            function () {
                return interval(_this.iosPollrate).pipe(flatMap((/**
                 * @return {?}
                 */
                function () { return _this.fs.fullscreenIsSupported(elm); })), distinctUntilChanged(), takeUntil(_this.ngOnDestroy$));
            }))
            : _this.fs.fullscreenIsSupported(elm); })), takeUntil(this.ngOnDestroy$))).pipe(takeUntil(this.ngOnDestroy$)).subscribe((/**
         * @param {?} res
         * @return {?}
         */
        function (res) {
            /** @type {?} */
            var isFullscreen = res[0];
            /** @type {?} */
            var isSupported = res[1];
            _this.vc.clear();
            if (_this.showWhenFullscreen) { // exit
                if (isFullscreen) {
                    _this.vc.createEmbeddedView(_this.tr);
                }
            }
            else if (!isFullscreen) { // enter
                if (isSupported) {
                    _this.vc.createEmbeddedView(_this.tr);
                }
            }
            _this.cd.detectChanges();
        }));
    };
    /**
     * @param {?} sc
     * @return {?}
     */
    FloFullscreenDirective.prototype.ngOnChanges = /**
     * @param {?} sc
     * @return {?}
     */
    function (sc) {
        if (this.elmInputKey && sc[this.elmInputKey]) {
            this.elmSource.next(sc[this.elmInputKey].currentValue);
        }
    };
    /**
     * @return {?}
     */
    FloFullscreenDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.ngOnDestroy$.next();
        this.ngOnDestroy$.complete();
    };
    /** @nocollapse */
    FloFullscreenDirective.ctorParameters = function () { return [
        { type: TemplateRef },
        { type: ViewContainerRef },
        { type: FloFullscreenService },
        { type: ChangeDetectorRef },
        { type: Boolean, decorators: [{ type: Inject, args: [FS_FULLSCREEN_IOS_POLL_ENABLED,] }] },
        { type: Number, decorators: [{ type: Inject, args: [FS_FULLSCREEN_IOS_POLL_MS,] }] },
        { type: NgZone }
    ]; };
    return FloFullscreenDirective;
}());
/** @type {?} */
var IF_FS_SELECTOR = 'floIfFullscreen';
var FloFullscreenOnDirective = /** @class */ (function (_super) {
    __extends(FloFullscreenOnDirective, _super);
    function FloFullscreenOnDirective(tr, vc, fs, cd, iosPollEnabled, iosPollrate, zone) {
        var _this = _super.call(this, tr, vc, fs, cd, iosPollEnabled, iosPollrate, zone) || this;
        _this.tr = tr;
        _this.vc = vc;
        _this.fs = fs;
        _this.cd = cd;
        _this.iosPollEnabled = iosPollEnabled;
        _this.iosPollrate = iosPollrate;
        _this.zone = zone;
        _this.elmInputKey = IF_FS_SELECTOR;
        _this.showWhenFullscreen = true;
        return _this;
    }
    FloFullscreenOnDirective.decorators = [
        { type: Directive, args: [{
                    selector: "[" + IF_FS_SELECTOR + "]",
                    inputs: [IF_FS_SELECTOR]
                },] }
    ];
    /** @nocollapse */
    FloFullscreenOnDirective.ctorParameters = function () { return [
        { type: TemplateRef },
        { type: ViewContainerRef },
        { type: FloFullscreenService },
        { type: ChangeDetectorRef },
        { type: Boolean, decorators: [{ type: Inject, args: [FS_FULLSCREEN_IOS_POLL_ENABLED,] }] },
        { type: Number, decorators: [{ type: Inject, args: [FS_FULLSCREEN_IOS_POLL_MS,] }] },
        { type: NgZone }
    ]; };
    return FloFullscreenOnDirective;
}(FloFullscreenDirective));
/** @type {?} */
var IF_NOT_FS_SELECTOR = 'floIfNotFullscreen';
var FloFullscreenOffDirective = /** @class */ (function (_super) {
    __extends(FloFullscreenOffDirective, _super);
    function FloFullscreenOffDirective(tr, vc, fs, cd, iosPollEnabled, iosPollrate, zone) {
        var _this = _super.call(this, tr, vc, fs, cd, iosPollEnabled, iosPollrate, zone) || this;
        _this.tr = tr;
        _this.vc = vc;
        _this.fs = fs;
        _this.cd = cd;
        _this.iosPollEnabled = iosPollEnabled;
        _this.iosPollrate = iosPollrate;
        _this.zone = zone;
        _this.elmInputKey = IF_NOT_FS_SELECTOR;
        _this.showWhenFullscreen = false;
        return _this;
    }
    FloFullscreenOffDirective.decorators = [
        { type: Directive, args: [{
                    selector: "[" + IF_NOT_FS_SELECTOR + "]",
                    inputs: [IF_NOT_FS_SELECTOR]
                },] }
    ];
    /** @nocollapse */
    FloFullscreenOffDirective.ctorParameters = function () { return [
        { type: TemplateRef },
        { type: ViewContainerRef },
        { type: FloFullscreenService },
        { type: ChangeDetectorRef },
        { type: Boolean, decorators: [{ type: Inject, args: [FS_FULLSCREEN_IOS_POLL_ENABLED,] }] },
        { type: Number, decorators: [{ type: Inject, args: [FS_FULLSCREEN_IOS_POLL_MS,] }] },
        { type: NgZone }
    ]; };
    return FloFullscreenOffDirective;
}(FloFullscreenDirective));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FloFullscreenSwitchModule = /** @class */ (function () {
    function FloFullscreenSwitchModule() {
    }
    FloFullscreenSwitchModule.decorators = [
        { type: NgModule, args: [{
                    imports: [FloFullscreenCommonModule],
                    declarations: [
                        FloFullscreenOnDirective,
                        FloFullscreenOffDirective
                    ],
                    exports: [
                        FloFullscreenOnDirective,
                        FloFullscreenOffDirective
                    ]
                },] }
    ];
    return FloFullscreenSwitchModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FloFullscreenModule = /** @class */ (function () {
    function FloFullscreenModule() {
    }
    FloFullscreenModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        FloFullscreenCommonModule,
                        FloFullscreenSwitchModule,
                        FloFullscreenToggleModule
                    ],
                    exports: [
                        FloFullscreenCommonModule,
                        FloFullscreenSwitchModule,
                        FloFullscreenToggleModule
                    ]
                },] }
    ];
    return FloFullscreenModule;
}());

export { DEFAULT_FS_FULLSCREEN_CHANGE_EVENTS, DEFAULT_FS_FULLSCREEN_ELEMENT, DEFAULT_FS_FULLSCREEN_ELEMENT_ERROR_EVENTS, DEFAULT_FS_FULLSCREEN_ENABLED, DEFAULT_FS_FULLSCREEN_ENABLED_FUNC, DEFAULT_FS_FULLSCREEN_EXIT_EVENTS, DEFAULT_FS_FULLSCREEN_IOS_POLL_ENABLED, DEFAULT_FS_FULLSCREEN_IOS_POLL_MS, DEFAULT_FS_FULLSCREEN_REQUEST_EVENTS, FS_FULLSCREEN_CHANGE_EVENTS, FS_FULLSCREEN_ELEMENT, FS_FULLSCREEN_ELEMENT_ERROR_EVENTS, FS_FULLSCREEN_ENABLED, FS_FULLSCREEN_ENABLED_FUNC, FS_FULLSCREEN_EXIT_EVENTS, FS_FULLSCREEN_IOS_POLL_ENABLED, FS_FULLSCREEN_IOS_POLL_MS, FS_FULLSCREEN_REQUEST_EVENTS, FloClickToEnterFullscreenDirective, FloClickToExitFullscreenDirective, FloFullscreenCommonModule, FloFullscreenDirective, FloFullscreenModule, FloFullscreenOffDirective, FloFullscreenOnDirective, FloFullscreenService, FloFullscreenSwitchModule, FloFullscreenToggleModule, isIphone };
//# sourceMappingURL=flosportsinc-ng-fullscreen.js.map
