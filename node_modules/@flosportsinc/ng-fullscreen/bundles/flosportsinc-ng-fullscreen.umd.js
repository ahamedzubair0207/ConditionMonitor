(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('rxjs'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('@flosportsinc/ng-fullscreen', ['exports', '@angular/core', '@angular/common', 'rxjs', 'rxjs/operators'], factory) :
    (global = global || self, factory((global.flosportsinc = global.flosportsinc || {}, global.flosportsinc['ng-fullscreen'] = {}), global.ng.core, global.ng.common, global.rxjs, global.rxjs.operators));
}(this, function (exports, core, common, rxjs, operators) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var isIphone = (/**
     * @return {?}
     */
    function () { return typeof window === 'undefined' || typeof window.navigator === 'undefined'
        ? false
        : window.navigator.userAgent.match(/iPhone/)
            ? true :
            false; });

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var FS_FULLSCREEN_REQUEST_EVENTS = new core.InjectionToken('fs.fullscreen.request');
    /** @type {?} */
    var FS_FULLSCREEN_EXIT_EVENTS = new core.InjectionToken('fs.fullscreen.exit');
    /** @type {?} */
    var FS_FULLSCREEN_CHANGE_EVENTS = new core.InjectionToken('fs.fullscreen.change');
    /** @type {?} */
    var FS_FULLSCREEN_ELEMENT_ERROR_EVENTS = new core.InjectionToken('fs.fullscreen.error');
    /** @type {?} */
    var FS_FULLSCREEN_ELEMENT = new core.InjectionToken('fs.fullscreen.element');
    /** @type {?} */
    var FS_FULLSCREEN_ENABLED = new core.InjectionToken('fs.fullscreen.enabled');
    /** @type {?} */
    var FS_FULLSCREEN_ENABLED_FUNC = new core.InjectionToken('fs.fullscreen.enabled-func');
    /** @type {?} */
    var FS_FULLSCREEN_IOS_POLL_ENABLED = new core.InjectionToken('fs.fullscreen.ios.poll.enabled');
    /** @type {?} */
    var FS_FULLSCREEN_IOS_POLL_MS = new core.InjectionToken('fs.fullscreen.ios.poll.ms');

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var isKeyTrue = (/**
     * @param {?} platformKeys
     * @return {?}
     */
    function (platformKeys) { return (/**
     * @param {?} doc
     * @return {?}
     */
    function (doc) {
        return platformKeys.reduce((/**
         * @param {?} acc
         * @param {?} curr
         * @return {?}
         */
        function (acc, curr) { return acc || doc[curr] ? true : false; }), false);
    }); });
    /** @type {?} */
    var fullscreenChangeError = (/**
     * @param {?} platformKeys
     * @return {?}
     */
    function (platformKeys) { return (/**
     * @param {?} doc
     * @return {?}
     */
    function (doc) {
        return rxjs.merge.apply(void 0, __spread(platformKeys.map((/**
         * @param {?} key
         * @return {?}
         */
        function (key) { return rxjs.fromEvent(doc, key); })))).pipe(operators.debounceTime(0));
    }); });
    /** @type {?} */
    var filterAndExecute = (/**
     * @param {?} ref
     * @return {?}
     */
    function (ref) { return (/**
     * @param {?} arr
     * @return {?}
     */
    function (arr) {
        /** @type {?} */
        var funcStringIdx = arr.findIndex((/**
         * @param {?} a
         * @return {?}
         */
        function (a) { return typeof ref[a] === 'function'; }));
        if (funcStringIdx >= 0) {
            ref[arr[funcStringIdx]]();
        }
    }); });
    var FloFullscreenService = /** @class */ (function () {
        // tslint:disable: readonly-array
        function FloFullscreenService(zone, doc, platformId, requestEventKeys, exitEventKeys, elementKeys, changeEventKeys, elementErrorEventKeys, enabledKeys, enabledFunc, iosPollrate, iosPollEnabled) {
            var _this = this;
            this.zone = zone;
            this.doc = doc;
            this.platformId = platformId;
            this.requestEventKeys = requestEventKeys;
            this.exitEventKeys = exitEventKeys;
            this.elementKeys = elementKeys;
            this.changeEventKeys = changeEventKeys;
            this.elementErrorEventKeys = elementErrorEventKeys;
            this.enabledKeys = enabledKeys;
            this.enabledFunc = enabledFunc;
            this.iosPollrate = iosPollrate;
            this.iosPollEnabled = iosPollEnabled;
            this.iOSVideoState = new rxjs.BehaviorSubject(false);
            this.isFullscreen = (/**
             * @param {?=} doc
             * @return {?}
             */
            function (doc) {
                if (doc === void 0) { doc = _this.doc; }
                return common.isPlatformServer(_this.platformId) ? false : isKeyTrue(_this.elementKeys)(doc) || _this.iOSVideoState.getValue();
            });
            this.fullscreenError$ = fullscreenChangeError(this.elementErrorEventKeys)(this.doc).pipe(operators.map((/**
             * @param {?} e
             * @return {?}
             */
            function (e) { return rxjs.throwError(e); })));
            this.iosVideoBypass = (/**
             * @param {?} pasthrough
             * @return {?}
             */
            function (pasthrough) { return isIphone() ? ['webkitEnterFullscreen'] : pasthrough; });
            this.extractVideoForIphoneIfRequired = (/**
             * @param {?} element
             * @return {?}
             */
            function (element) { return isIphone() && !(element instanceof HTMLVideoElement)
                ? element.querySelector('video') || element
                : element; });
            this.iosPoller = (/**
             * @return {?}
             */
            function () { return !_this.iosPollEnabled
                ? rxjs.EMPTY
                : _this.zone.runOutsideAngular((/**
                 * @return {?}
                 */
                function () {
                    return rxjs.interval(_this.iosPollrate).pipe(operators.map((/**
                     * @return {?}
                     */
                    function () { return Array.from(((/** @type {?} */ (_this.doc))).querySelectorAll('video')); })), operators.flatMap((/**
                     * @param {?} videoElements
                     * @return {?}
                     */
                    function (videoElements) { return rxjs.merge.apply(void 0, __spread(videoElements.map((/**
                     * @param {?} ve
                     * @return {?}
                     */
                    function (ve) { return rxjs.fromEvent(ve, 'webkitbeginfullscreen').pipe(operators.tap((/**
                     * @return {?}
                     */
                    function () { return _this.iOSVideoState.next(true); })), operators.take(1)); })), videoElements.map((/**
                     * @param {?} ve
                     * @return {?}
                     */
                    function (ve) { return rxjs.fromEvent(ve, 'webkitendfullscreen').pipe(operators.tap((/**
                     * @return {?}
                     */
                    function () { return _this.iOSVideoState.next(false); })), operators.take(1)); })))); })), operators.takeUntil(_this.iOSVideoState));
                })); });
            this.fullscreen$ = common.isPlatformServer(this.platformId)
                ? rxjs.of(false)
                : rxjs.merge.apply(void 0, __spread(this.changeEventKeys.map((/**
                 * @param {?} key
                 * @return {?}
                 */
                function (key) { return rxjs.fromEvent(_this.doc, key); })), [this.fullscreenError$,
                    this.iosPoller()])).pipe(operators.debounceTime(0), operators.map((/**
                 * @return {?}
                 */
                function () { return _this.isFullscreen(); })), operators.distinctUntilChanged(), operators.startWith(this.isFullscreen()), operators.shareReplay(1));
            this.fullscreenIsSupported = (/**
             * @param {?=} elm
             * @return {?}
             */
            function (elm) {
                return (common.isPlatformServer(_this.platformId)
                    ? rxjs.of(false)
                    : isKeyTrue(_this.enabledKeys)(_this.doc)
                        ? rxjs.of(true)
                        : !elm
                            ? rxjs.of(false)
                            : _this.enabledFunc(elm)).pipe(operators.shareReplay(1));
            });
            this.canGoFullscreen = (/**
             * @param {?=} elm
             * @return {?}
             */
            function (elm) {
                return (common.isPlatformServer(_this.platformId)
                    ? rxjs.of(false)
                    : _this.fullscreenIsSupported(elm)
                        .pipe(operators.flatMap((/**
                     * @param {?} isSupported
                     * @return {?}
                     */
                    function (isSupported) { return !isSupported
                        ? rxjs.of(false)
                        : _this.fullscreen$.pipe(operators.map((/**
                         * @param {?} isfs
                         * @return {?}
                         */
                        function (isfs) { return isfs ? false : true; }))); })))).pipe(operators.shareReplay(1));
            });
            this.isFullscreen$ = this.fullscreen$.pipe(operators.filter((/**
             * @param {?} v
             * @return {?}
             */
            function (v) { return v === true; })));
            this.isNotFullscreen = this.fullscreen$.pipe(operators.filter((/**
             * @param {?} v
             * @return {?}
             */
            function (v) { return v === false; })));
            this.exitFullscreen = (/**
             * @return {?}
             */
            function () { return filterAndExecute(_this.doc)(_this.exitEventKeys); });
            this.goFullscreen = (/**
             * @param {?=} elm
             * @return {?}
             */
            function (elm) {
                if (elm === void 0) { elm = _this.doc.body; }
                return filterAndExecute(elm)(_this.iosVideoBypass(_this.requestEventKeys));
            });
        }
        FloFullscreenService.decorators = [
            { type: core.Injectable, args: [{ providedIn: 'root' },] }
        ];
        /** @nocollapse */
        FloFullscreenService.ctorParameters = function () { return [
            { type: core.NgZone },
            { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] },
            { type: String, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] },
            { type: Array, decorators: [{ type: core.Inject, args: [FS_FULLSCREEN_REQUEST_EVENTS,] }] },
            { type: Array, decorators: [{ type: core.Inject, args: [FS_FULLSCREEN_EXIT_EVENTS,] }] },
            { type: Array, decorators: [{ type: core.Inject, args: [FS_FULLSCREEN_ELEMENT,] }] },
            { type: Array, decorators: [{ type: core.Inject, args: [FS_FULLSCREEN_CHANGE_EVENTS,] }] },
            { type: Array, decorators: [{ type: core.Inject, args: [FS_FULLSCREEN_ELEMENT_ERROR_EVENTS,] }] },
            { type: Array, decorators: [{ type: core.Inject, args: [FS_FULLSCREEN_ENABLED,] }] },
            { type: undefined, decorators: [{ type: core.Inject, args: [FS_FULLSCREEN_ENABLED_FUNC,] }] },
            { type: Number, decorators: [{ type: core.Inject, args: [FS_FULLSCREEN_IOS_POLL_MS,] }] },
            { type: Boolean, decorators: [{ type: core.Inject, args: [FS_FULLSCREEN_IOS_POLL_ENABLED,] }] }
        ]; };
        /** @nocollapse */ FloFullscreenService.ngInjectableDef = core.defineInjectable({ factory: function FloFullscreenService_Factory() { return new FloFullscreenService(core.inject(core.NgZone), core.inject(common.DOCUMENT), core.inject(core.PLATFORM_ID), core.inject(FS_FULLSCREEN_REQUEST_EVENTS), core.inject(FS_FULLSCREEN_EXIT_EVENTS), core.inject(FS_FULLSCREEN_ELEMENT), core.inject(FS_FULLSCREEN_CHANGE_EVENTS), core.inject(FS_FULLSCREEN_ELEMENT_ERROR_EVENTS), core.inject(FS_FULLSCREEN_ENABLED), core.inject(FS_FULLSCREEN_ENABLED_FUNC), core.inject(FS_FULLSCREEN_IOS_POLL_MS), core.inject(FS_FULLSCREEN_IOS_POLL_ENABLED)); }, token: FloFullscreenService, providedIn: "root" });
        return FloFullscreenService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DEFAULT_FS_FULLSCREEN_REQUEST_EVENTS = [
        'requestFullscreen',
        'webkitRequestFullscreen',
        'webkitRequestFullScreen',
        'mozRequestFullScreen',
        'msRequestFullscreen'
    ];
    /** @type {?} */
    var DEFAULT_FS_FULLSCREEN_EXIT_EVENTS = [
        'exitFullscreen',
        'webkitExitFullscreen',
        'webkitCancelFullScreen',
        'mozCancelFullScreen',
        'msExitFullscreen'
    ];
    /** @type {?} */
    var DEFAULT_FS_FULLSCREEN_ELEMENT_ERROR_EVENTS = [
        'fullscreenerror',
        'webkitfullscreenerror',
        'webkitfullscreenerror',
        'mozfullscreenerror',
        'MSFullscreenError'
    ];
    /** @type {?} */
    var DEFAULT_FS_FULLSCREEN_ELEMENT = [
        'fullscreenElement',
        'webkitFullscreenElement',
        'webkitCurrentFullScreenElement',
        'mozFullScreenElement',
        'msFullscreenElement'
    ];
    /** @type {?} */
    var DEFAULT_FS_FULLSCREEN_ENABLED = [
        'fullscreenEnabled',
        'mozFullscreenEnabled',
        'webkitFullscreenEnabled',
        'msFullscreenEnabled'
    ];
    /** @type {?} */
    var DEFAULT_FS_FULLSCREEN_CHANGE_EVENTS = [
        'fullscreenchange',
        'webkitfullscreenchange',
        'mozfullscreenchange',
        'MSFullscreenChange'
    ];
    /**
     * @return {?}
     */
    function DEFAULT_FS_FULLSCREEN_ENABLED_FUNC() {
        /** @type {?} */
        var lambda = (/**
         * @param {?} elm
         * @return {?}
         */
        function (elm) {
            /** @type {?} */
            var _elm = elm instanceof HTMLVideoElement ? elm : elm.querySelector('video');
            return !_elm ? rxjs.of(false) : ((/** @type {?} */ (_elm))).readyState >= 2
                ? rxjs.of(true)
                : rxjs.fromEvent(_elm, 'loadedmetadata').pipe(operators.map((/**
                 * @param {?} evt
                 * @return {?}
                 */
                function (evt) { return !evt.target ? false : ((/** @type {?} */ (evt.target))).webkitSupportsFullscreen; })), operators.take(1));
        });
        return lambda;
    }
    /** @type {?} */
    var DEFAULT_FS_FULLSCREEN_IOS_POLL_ENABLED = true;
    /** @type {?} */
    var DEFAULT_FS_FULLSCREEN_IOS_POLL_MS = 60;

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ɵ0 = DEFAULT_FS_FULLSCREEN_REQUEST_EVENTS, ɵ1 = DEFAULT_FS_FULLSCREEN_EXIT_EVENTS, ɵ2 = DEFAULT_FS_FULLSCREEN_CHANGE_EVENTS, ɵ3 = DEFAULT_FS_FULLSCREEN_ELEMENT_ERROR_EVENTS, ɵ4 = DEFAULT_FS_FULLSCREEN_ELEMENT, ɵ5 = DEFAULT_FS_FULLSCREEN_ENABLED, ɵ6 = DEFAULT_FS_FULLSCREEN_ENABLED_FUNC, ɵ7 = DEFAULT_FS_FULLSCREEN_IOS_POLL_MS, ɵ8 = DEFAULT_FS_FULLSCREEN_IOS_POLL_ENABLED;
    var FloFullscreenCommonModule = /** @class */ (function () {
        function FloFullscreenCommonModule() {
        }
        /**
         * @param {?} config
         * @return {?}
         */
        FloFullscreenCommonModule.config = /**
         * @param {?} config
         * @return {?}
         */
        function (config) {
            return {
                ngModule: FloFullscreenCommonModule,
                providers: [
                    {
                        provide: FS_FULLSCREEN_IOS_POLL_ENABLED,
                        useValue: config.ios && typeof config.ios.enabled === 'boolean' ? config.ios.enabled : DEFAULT_FS_FULLSCREEN_IOS_POLL_ENABLED
                    },
                    {
                        provide: FS_FULLSCREEN_IOS_POLL_MS,
                        useValue: config.ios && typeof config.ios.pollDurationMs === 'number'
                            ? config.ios.pollDurationMs
                            : DEFAULT_FS_FULLSCREEN_IOS_POLL_MS
                    }
                ]
            };
        };
        FloFullscreenCommonModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [common.CommonModule],
                        providers: [
                            FloFullscreenService,
                            { provide: FS_FULLSCREEN_REQUEST_EVENTS, useValue: ɵ0 },
                            { provide: FS_FULLSCREEN_EXIT_EVENTS, useValue: ɵ1 },
                            { provide: FS_FULLSCREEN_CHANGE_EVENTS, useValue: ɵ2 },
                            { provide: FS_FULLSCREEN_ELEMENT_ERROR_EVENTS, useValue: ɵ3 },
                            { provide: FS_FULLSCREEN_ELEMENT, useValue: ɵ4 },
                            { provide: FS_FULLSCREEN_ENABLED, useValue: ɵ5 },
                            { provide: FS_FULLSCREEN_ENABLED_FUNC, useFactory: ɵ6 },
                            { provide: FS_FULLSCREEN_IOS_POLL_MS, useValue: ɵ7 },
                            { provide: FS_FULLSCREEN_IOS_POLL_ENABLED, useValue: ɵ8 }
                        ]
                    },] }
        ];
        return FloFullscreenCommonModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // tslint:disable: readonly-keyword
    // tslint:disable: no-object-mutation
    var FloClickToEnterFullscreenDirective = /** @class */ (function () {
        function FloClickToEnterFullscreenDirective(fs, doc, cd) {
            this.fs = fs;
            this.doc = doc;
            this.cd = cd;
        }
        Object.defineProperty(FloClickToEnterFullscreenDirective.prototype, "floClickToEnterFullscreen", {
            get: /**
             * @return {?}
             */
            function () {
                return this._element;
            },
            set: /**
             * @param {?} val
             * @return {?}
             */
            function (val) {
                if (val instanceof HTMLElement) {
                    this._element = val;
                }
                else {
                    this._element = this.doc.body;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        FloClickToEnterFullscreenDirective.prototype.click = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.cd.detectChanges();
            this.fs.isNotFullscreen.pipe(operators.take(1)).subscribe((/**
             * @param {?} _
             * @return {?}
             */
            function (_) {
                // should check for nested video elements to make iOS dev easier
                _this.fs.goFullscreen(_this.fs.extractVideoForIphoneIfRequired(_this.floClickToEnterFullscreen));
            }));
        };
        FloClickToEnterFullscreenDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[floClickToEnterFullscreen]',
                    },] }
        ];
        /** @nocollapse */
        FloClickToEnterFullscreenDirective.ctorParameters = function () { return [
            { type: FloFullscreenService },
            { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] },
            { type: core.ChangeDetectorRef }
        ]; };
        FloClickToEnterFullscreenDirective.propDecorators = {
            floClickToEnterFullscreen: [{ type: core.Input }],
            click: [{ type: core.HostListener, args: ['click', [],] }]
        };
        return FloClickToEnterFullscreenDirective;
    }());
    var FloClickToExitFullscreenDirective = /** @class */ (function () {
        function FloClickToExitFullscreenDirective(fs) {
            this.fs = fs;
        }
        /**
         * @return {?}
         */
        FloClickToExitFullscreenDirective.prototype.click = /**
         * @return {?}
         */
        function () {
            this.fs.exitFullscreen();
        };
        FloClickToExitFullscreenDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[floClickToExitFullscreen]',
                    },] }
        ];
        /** @nocollapse */
        FloClickToExitFullscreenDirective.ctorParameters = function () { return [
            { type: FloFullscreenService }
        ]; };
        FloClickToExitFullscreenDirective.propDecorators = {
            click: [{ type: core.HostListener, args: ['click', [],] }]
        };
        return FloClickToExitFullscreenDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var FloFullscreenToggleModule = /** @class */ (function () {
        function FloFullscreenToggleModule() {
        }
        FloFullscreenToggleModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [FloFullscreenCommonModule],
                        declarations: [
                            FloClickToEnterFullscreenDirective,
                            FloClickToExitFullscreenDirective
                        ],
                        exports: [
                            FloClickToEnterFullscreenDirective,
                            FloClickToExitFullscreenDirective
                        ]
                    },] }
        ];
        return FloFullscreenToggleModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // tslint:disable: readonly-keyword
    /**
     * @abstract
     */
    var FloFullscreenDirective = /** @class */ (function () {
        function FloFullscreenDirective(tr, vc, fs, cd, iosPollEnabled, iosPollrate, zone) {
            var _this = this;
            this.tr = tr;
            this.vc = vc;
            this.fs = fs;
            this.cd = cd;
            this.iosPollEnabled = iosPollEnabled;
            this.iosPollrate = iosPollrate;
            this.zone = zone;
            this.elmSource = new rxjs.Subject();
            this.showWhenFullscreen = false;
            this.ngOnDestroy$ = new rxjs.Subject();
            this.elm = (/**
             * @return {?}
             */
            function () { return _this.elmInputKey ? (/** @type {?} */ (_this[_this.elmInputKey])) : undefined; });
            this.elm$ = this.elmSource.asObservable();
        }
        /**
         * @return {?}
         */
        FloFullscreenDirective.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            rxjs.combineLatest(this.fs.fullscreen$, this.elm$.pipe(operators.tap((/**
             * @return {?}
             */
            function () { return _this.cd.detectChanges(); })), operators.startWith(this.elm()), operators.delay(0), operators.flatMap((/**
             * @param {?} elm
             * @return {?}
             */
            function (elm) { return _this.iosPollEnabled && isIphone()
                ? _this.zone.runOutsideAngular((/**
                 * @return {?}
                 */
                function () {
                    return rxjs.interval(_this.iosPollrate).pipe(operators.flatMap((/**
                     * @return {?}
                     */
                    function () { return _this.fs.fullscreenIsSupported(elm); })), operators.distinctUntilChanged(), operators.takeUntil(_this.ngOnDestroy$));
                }))
                : _this.fs.fullscreenIsSupported(elm); })), operators.takeUntil(this.ngOnDestroy$))).pipe(operators.takeUntil(this.ngOnDestroy$)).subscribe((/**
             * @param {?} res
             * @return {?}
             */
            function (res) {
                /** @type {?} */
                var isFullscreen = res[0];
                /** @type {?} */
                var isSupported = res[1];
                _this.vc.clear();
                if (_this.showWhenFullscreen) { // exit
                    if (isFullscreen) {
                        _this.vc.createEmbeddedView(_this.tr);
                    }
                }
                else if (!isFullscreen) { // enter
                    if (isSupported) {
                        _this.vc.createEmbeddedView(_this.tr);
                    }
                }
                _this.cd.detectChanges();
            }));
        };
        /**
         * @param {?} sc
         * @return {?}
         */
        FloFullscreenDirective.prototype.ngOnChanges = /**
         * @param {?} sc
         * @return {?}
         */
        function (sc) {
            if (this.elmInputKey && sc[this.elmInputKey]) {
                this.elmSource.next(sc[this.elmInputKey].currentValue);
            }
        };
        /**
         * @return {?}
         */
        FloFullscreenDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.ngOnDestroy$.next();
            this.ngOnDestroy$.complete();
        };
        /** @nocollapse */
        FloFullscreenDirective.ctorParameters = function () { return [
            { type: core.TemplateRef },
            { type: core.ViewContainerRef },
            { type: FloFullscreenService },
            { type: core.ChangeDetectorRef },
            { type: Boolean, decorators: [{ type: core.Inject, args: [FS_FULLSCREEN_IOS_POLL_ENABLED,] }] },
            { type: Number, decorators: [{ type: core.Inject, args: [FS_FULLSCREEN_IOS_POLL_MS,] }] },
            { type: core.NgZone }
        ]; };
        return FloFullscreenDirective;
    }());
    /** @type {?} */
    var IF_FS_SELECTOR = 'floIfFullscreen';
    var FloFullscreenOnDirective = /** @class */ (function (_super) {
        __extends(FloFullscreenOnDirective, _super);
        function FloFullscreenOnDirective(tr, vc, fs, cd, iosPollEnabled, iosPollrate, zone) {
            var _this = _super.call(this, tr, vc, fs, cd, iosPollEnabled, iosPollrate, zone) || this;
            _this.tr = tr;
            _this.vc = vc;
            _this.fs = fs;
            _this.cd = cd;
            _this.iosPollEnabled = iosPollEnabled;
            _this.iosPollrate = iosPollrate;
            _this.zone = zone;
            _this.elmInputKey = IF_FS_SELECTOR;
            _this.showWhenFullscreen = true;
            return _this;
        }
        FloFullscreenOnDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: "[" + IF_FS_SELECTOR + "]",
                        inputs: [IF_FS_SELECTOR]
                    },] }
        ];
        /** @nocollapse */
        FloFullscreenOnDirective.ctorParameters = function () { return [
            { type: core.TemplateRef },
            { type: core.ViewContainerRef },
            { type: FloFullscreenService },
            { type: core.ChangeDetectorRef },
            { type: Boolean, decorators: [{ type: core.Inject, args: [FS_FULLSCREEN_IOS_POLL_ENABLED,] }] },
            { type: Number, decorators: [{ type: core.Inject, args: [FS_FULLSCREEN_IOS_POLL_MS,] }] },
            { type: core.NgZone }
        ]; };
        return FloFullscreenOnDirective;
    }(FloFullscreenDirective));
    /** @type {?} */
    var IF_NOT_FS_SELECTOR = 'floIfNotFullscreen';
    var FloFullscreenOffDirective = /** @class */ (function (_super) {
        __extends(FloFullscreenOffDirective, _super);
        function FloFullscreenOffDirective(tr, vc, fs, cd, iosPollEnabled, iosPollrate, zone) {
            var _this = _super.call(this, tr, vc, fs, cd, iosPollEnabled, iosPollrate, zone) || this;
            _this.tr = tr;
            _this.vc = vc;
            _this.fs = fs;
            _this.cd = cd;
            _this.iosPollEnabled = iosPollEnabled;
            _this.iosPollrate = iosPollrate;
            _this.zone = zone;
            _this.elmInputKey = IF_NOT_FS_SELECTOR;
            _this.showWhenFullscreen = false;
            return _this;
        }
        FloFullscreenOffDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: "[" + IF_NOT_FS_SELECTOR + "]",
                        inputs: [IF_NOT_FS_SELECTOR]
                    },] }
        ];
        /** @nocollapse */
        FloFullscreenOffDirective.ctorParameters = function () { return [
            { type: core.TemplateRef },
            { type: core.ViewContainerRef },
            { type: FloFullscreenService },
            { type: core.ChangeDetectorRef },
            { type: Boolean, decorators: [{ type: core.Inject, args: [FS_FULLSCREEN_IOS_POLL_ENABLED,] }] },
            { type: Number, decorators: [{ type: core.Inject, args: [FS_FULLSCREEN_IOS_POLL_MS,] }] },
            { type: core.NgZone }
        ]; };
        return FloFullscreenOffDirective;
    }(FloFullscreenDirective));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var FloFullscreenSwitchModule = /** @class */ (function () {
        function FloFullscreenSwitchModule() {
        }
        FloFullscreenSwitchModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [FloFullscreenCommonModule],
                        declarations: [
                            FloFullscreenOnDirective,
                            FloFullscreenOffDirective
                        ],
                        exports: [
                            FloFullscreenOnDirective,
                            FloFullscreenOffDirective
                        ]
                    },] }
        ];
        return FloFullscreenSwitchModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var FloFullscreenModule = /** @class */ (function () {
        function FloFullscreenModule() {
        }
        FloFullscreenModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            FloFullscreenCommonModule,
                            FloFullscreenSwitchModule,
                            FloFullscreenToggleModule
                        ],
                        exports: [
                            FloFullscreenCommonModule,
                            FloFullscreenSwitchModule,
                            FloFullscreenToggleModule
                        ]
                    },] }
        ];
        return FloFullscreenModule;
    }());

    exports.DEFAULT_FS_FULLSCREEN_CHANGE_EVENTS = DEFAULT_FS_FULLSCREEN_CHANGE_EVENTS;
    exports.DEFAULT_FS_FULLSCREEN_ELEMENT = DEFAULT_FS_FULLSCREEN_ELEMENT;
    exports.DEFAULT_FS_FULLSCREEN_ELEMENT_ERROR_EVENTS = DEFAULT_FS_FULLSCREEN_ELEMENT_ERROR_EVENTS;
    exports.DEFAULT_FS_FULLSCREEN_ENABLED = DEFAULT_FS_FULLSCREEN_ENABLED;
    exports.DEFAULT_FS_FULLSCREEN_ENABLED_FUNC = DEFAULT_FS_FULLSCREEN_ENABLED_FUNC;
    exports.DEFAULT_FS_FULLSCREEN_EXIT_EVENTS = DEFAULT_FS_FULLSCREEN_EXIT_EVENTS;
    exports.DEFAULT_FS_FULLSCREEN_IOS_POLL_ENABLED = DEFAULT_FS_FULLSCREEN_IOS_POLL_ENABLED;
    exports.DEFAULT_FS_FULLSCREEN_IOS_POLL_MS = DEFAULT_FS_FULLSCREEN_IOS_POLL_MS;
    exports.DEFAULT_FS_FULLSCREEN_REQUEST_EVENTS = DEFAULT_FS_FULLSCREEN_REQUEST_EVENTS;
    exports.FS_FULLSCREEN_CHANGE_EVENTS = FS_FULLSCREEN_CHANGE_EVENTS;
    exports.FS_FULLSCREEN_ELEMENT = FS_FULLSCREEN_ELEMENT;
    exports.FS_FULLSCREEN_ELEMENT_ERROR_EVENTS = FS_FULLSCREEN_ELEMENT_ERROR_EVENTS;
    exports.FS_FULLSCREEN_ENABLED = FS_FULLSCREEN_ENABLED;
    exports.FS_FULLSCREEN_ENABLED_FUNC = FS_FULLSCREEN_ENABLED_FUNC;
    exports.FS_FULLSCREEN_EXIT_EVENTS = FS_FULLSCREEN_EXIT_EVENTS;
    exports.FS_FULLSCREEN_IOS_POLL_ENABLED = FS_FULLSCREEN_IOS_POLL_ENABLED;
    exports.FS_FULLSCREEN_IOS_POLL_MS = FS_FULLSCREEN_IOS_POLL_MS;
    exports.FS_FULLSCREEN_REQUEST_EVENTS = FS_FULLSCREEN_REQUEST_EVENTS;
    exports.FloClickToEnterFullscreenDirective = FloClickToEnterFullscreenDirective;
    exports.FloClickToExitFullscreenDirective = FloClickToExitFullscreenDirective;
    exports.FloFullscreenCommonModule = FloFullscreenCommonModule;
    exports.FloFullscreenDirective = FloFullscreenDirective;
    exports.FloFullscreenModule = FloFullscreenModule;
    exports.FloFullscreenOffDirective = FloFullscreenOffDirective;
    exports.FloFullscreenOnDirective = FloFullscreenOnDirective;
    exports.FloFullscreenService = FloFullscreenService;
    exports.FloFullscreenSwitchModule = FloFullscreenSwitchModule;
    exports.FloFullscreenToggleModule = FloFullscreenToggleModule;
    exports.isIphone = isIphone;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=flosportsinc-ng-fullscreen.umd.js.map
